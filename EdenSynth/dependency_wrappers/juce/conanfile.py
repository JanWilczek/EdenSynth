from conan import ConanFile
from conan.tools.cmake import CMakeToolchain, CMake, cmake_layout
from conan.tools.scm import Git
import os


class JuceConanfile(ConanFile):
    name = "juce"
    version = "7.0.3"
    url = "https://github.com/juce-framework/JUCE.git"
    description = "JUCE is an open-source cross-platform C++ application framework for desktop and mobile applications, including VST, VST3, AU, AUv3, LV2 and AAX audio plug-ins."
    license = "https://github.com/juce-framework/JUCE/blob/master/LICENSE.md"
    homepage = "https://juce.com/"

    # Project-wide configuration that cannot be defaulted in recipes.
    # For pacakge-specific configuration that can be defaulted check out the `options` field.
    settings = "os", "compiler", "arch", "build_type"

    # layout() should specify locations of source files and destination files generated during build.
    def layout(self):
        # Calling this function will set those locations as expected of a CMake project,
        # for example, "build" for the binary directory.
        cmake_layout(self)

    def source(self):
        git = Git(self)
        # Do not create an extra subfolder for the repo.
        git.clone(url=self.url, target=".")
        git.checkout(f"tags/{self.version}")

    # The purpose of generate() is to prepare the build, generating the necessary files, such as
    # Files containing information to locate the dependencies, environment activation scripts,
    # and specific build system files among others
    def generate(self):
        # There are no requires() so we don't have to generate dependencies using CMakeDeps.
        tc = CMakeToolchain(self)
        # This generates the CMake toolchain file.
        tc.generate()

    # This method is used to build the source code of the recipe using the desired commands.
    def build(self):
        # Wrapper around CMake commands.
        cmake = CMake(self)
        # This passes the generated toolchain file to CMake under the hood. It is the CMake configure step for this package.
        cmake.configure()
        # This is the build step for this package.
        cmake.build()

    # The actual creation of the package, once it's built, is done in the package() method.
    # This method copies artifacts (headers, libs) from the build folder to the final package folder.
    def package(self):
        cmake = CMake(self)
        # CMake has the copy functionality on its own so we can simply use it.
        # The toolchain file generated by Conan should ensure proper directories.
        cmake.install()

    # This method defines information necessary for consumers of the JUCE package.
    def package_info(self):
        # This is JUCE-specific; instead of exposing include paths or libraries to link against,
        # it exposes JUCE's CMake utilities so that it's easier to interact with it using their APIs.
        self.cpp_info.set_property("cmake_find_mode", "none")
        # These are the most dubious: isn't there an easier way to do it?
        self.cpp_info.builddirs.append(
            os.path.join("lib", "cmake", f"JUCE-{self.version}")
        )
        self.buildenv_info.append_path(
            "PATH",
            os.path.join(str(self.package_folder), "bin", f"JUCE-{self.version}"),
        )
